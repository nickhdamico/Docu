---
title: "Authentication"
description: "Secure WebSocket connection for private account data"
---

## Overview

Authenticated WebSocket connections enable access to private account data including order updates, balance changes, position updates, and account notifications. Authentication uses API credentials and HMAC signatures for security.

## Authentication Requirements

To establish an authenticated connection, you need:

1. **API Key**: Your account's API key with appropriate permissions
2. **API Secret**: Used to generate HMAC signatures (never transmitted)
3. **Timestamp**: Current timestamp in milliseconds
4. **HMAC Signature**: Base64-encoded HMAC-SHA256 signature

## Connection Headers

Include these headers when establishing the WebSocket connection:

| Header | Description | Example |
|--------|-------------|---------|
| `X-API-KEY` | Your API key | `"your-api-key-here"` |
| `X-API-TIMESTAMP` | Current timestamp in milliseconds | `"1640995200000"` |
| `X-API-SIGN` | Base64-encoded HMAC signature | `"generated-signature"` |

## HMAC Signature Generation

The signature is generated by creating an HMAC-SHA256 hash of the timestamp using your API secret:

<CodeGroup>
```javascript JavaScript
function generateHMACSignature(secret, timestamp) {
  const crypto = require('crypto');
  return crypto
    .createHmac('sha256', secret)
    .update(timestamp)
    .digest('base64');
}

// Usage
const timestamp = Date.now().toString();
const signature = generateHMACSignature(apiSecret, timestamp);
```

```python Python
import hmac
import hashlib
import base64
import time

def generate_hmac_signature(secret, timestamp):
    signature = hmac.new(
        secret.encode('utf-8'),
        timestamp.encode('utf-8'),
        hashlib.sha256
    ).digest()
    return base64.b64encode(signature).decode('utf-8')

# Usage
timestamp = str(int(time.time() * 1000))
signature = generate_hmac_signature(api_secret, timestamp)
```

```go Go
import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/base64"
    "strconv"
    "time"
)

func generateHMACSignature(secret, timestamp string) string {
    h := hmac.New(sha256.New, []byte(secret))
    h.Write([]byte(timestamp))
    return base64.StdEncoding.EncodeToString(h.Sum(nil))
}

// Usage
timestamp := strconv.FormatInt(time.Now().UnixNano()/1000000, 10)
signature := generateHMACSignature(apiSecret, timestamp)
```
</CodeGroup>

## Authenticated Connection Examples

### JavaScript Example

<CodeGroup>
```javascript Browser
const apiKey = 'your-api-key';
const apiSecret = 'your-api-secret';

function createAuthenticatedConnection() {
  const timestamp = Date.now().toString();
  const signature = generateHMACSignature(apiSecret, timestamp);

  const headers = {
    'X-API-KEY': apiKey,
    'X-API-TIMESTAMP': timestamp,
    'X-API-SIGN': signature
  };

  const ws = new WebSocket('wss://ws.roxom.com/ws', [], { headers });

  ws.onopen = function() {
    console.log('🔐 Authenticated connection established');
    // Private streams are automatically enabled
  };

  ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    
    // Handle private account data
    switch (data.type) {
      case 'order':
        handleOrderUpdate(data.data);
        break;
      case 'balance':
        handleBalanceUpdate(data.data);
        break;
      case 'position':
        handlePositionUpdate(data.data);
        break;
    }
  };

  return ws;
}

function generateHMACSignature(secret, timestamp) {
  const crypto = require('crypto');
  return crypto
    .createHmac('sha256', secret)
    .update(timestamp)
    .digest('base64');
}
```

```javascript Node.js
const WebSocket = require('ws');
const crypto = require('crypto');

class AuthenticatedWebSocket {
  constructor(apiKey, apiSecret) {
    this.apiKey = apiKey;
    this.apiSecret = apiSecret;
    this.ws = null;
  }

  connect() {
    const timestamp = Date.now().toString();
    const signature = this.generateSignature(timestamp);

    const headers = {
      'X-API-KEY': this.apiKey,
      'X-API-TIMESTAMP': timestamp,
      'X-API-SIGN': signature
    };

    this.ws = new WebSocket('wss://ws.roxom.com/ws', { headers });

    this.ws.on('open', () => {
      console.log('🔐 Authenticated WebSocket connected');
    });

    this.ws.on('message', (data) => {
      const message = JSON.parse(data);
      this.handlePrivateMessage(message);
    });

    this.ws.on('error', (error) => {
      console.error('WebSocket error:', error);
    });

    this.ws.on('close', () => {
      console.log('WebSocket connection closed');
      this.reconnect();
    });
  }

  generateSignature(timestamp) {
    return crypto
      .createHmac('sha256', this.apiSecret)
      .update(timestamp)
      .digest('base64');
  }

  handlePrivateMessage(message) {
    console.log('Private message:', message);
  }

  reconnect() {
    setTimeout(() => {
      console.log('Reconnecting...');
      this.connect();
    }, 5000);
  }
}

// Usage
const client = new AuthenticatedWebSocket('your-api-key', 'your-api-secret');
client.connect();
```
</CodeGroup>

### Python Example

<CodeGroup>
```python websocket-client
import websocket
import json
import hmac
import hashlib
import base64
import time

class AuthenticatedWebSocketClient:
    def __init__(self, api_key, api_secret):
        self.api_key = api_key
        self.api_secret = api_secret
        self.ws = None

    def generate_signature(self, timestamp):
        signature = hmac.new(
            self.api_secret.encode('utf-8'),
            timestamp.encode('utf-8'),
            hashlib.sha256
        ).digest()
        return base64.b64encode(signature).decode('utf-8')

    def connect(self):
        timestamp = str(int(time.time() * 1000))
        signature = self.generate_signature(timestamp)

        headers = {
            'X-API-KEY': self.api_key,
            'X-API-TIMESTAMP': timestamp,
            'X-API-SIGN': signature
        }

        self.ws = websocket.WebSocketApp(
            "wss://ws.roxom.com/ws",
            header=headers,
            on_open=self.on_open,
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close
        )

        self.ws.run_forever()

    def on_open(self, ws):
        print("🔐 Authenticated WebSocket connected")

    def on_message(self, ws, message):
        data = json.loads(message)
        self.handle_private_message(data)

    def on_error(self, ws, error):
        print(f"WebSocket error: {error}")

    def on_close(self, ws, close_status_code, close_msg):
        print("WebSocket connection closed")

    def handle_private_message(self, data):
        message_type = data.get('type')
        
        if message_type == 'order':
            self.handle_order_update(data['data'])
        elif message_type == 'balance':
            self.handle_balance_update(data['data'])
        elif message_type == 'position':
            self.handle_position_update(data['data'])

    def handle_order_update(self, order_data):
        print(f"📋 Order update: {order_data['orderId']} -> {order_data['status']}")

    def handle_balance_update(self, balance_data):
        print(f"💰 Balance update: {balance_data['units']} {balance_data['amount']}")

    def handle_position_update(self, position_data):
        print(f"📊 Position update: {position_data['symbol']} PnL: {position_data['unrealizedPnl']}")

# Usage
client = AuthenticatedWebSocketClient('your-api-key', 'your-api-secret')
client.connect()
```

```python asyncio
import asyncio
import websockets
import json
import hmac
import hashlib
import base64
import time

async def authenticated_websocket_client(api_key, api_secret):
    # Generate authentication headers
    timestamp = str(int(time.time() * 1000))
    signature = hmac.new(
        api_secret.encode('utf-8'),
        timestamp.encode('utf-8'),
        hashlib.sha256
    ).digest()
    signature_b64 = base64.b64encode(signature).decode('utf-8')

    headers = {
        'X-API-KEY': api_key,
        'X-API-TIMESTAMP': timestamp,
        'X-API-SIGN': signature_b64
    }

    uri = "wss://ws.roxom.com/ws"
    
    async with websockets.connect(uri, extra_headers=headers) as websocket:
        print("🔐 Authenticated WebSocket connected")
        
        async for message in websocket:
            data = json.loads(message)
            
            # Handle private account messages
            if data.get('type') == 'order':
                print(f"📋 Order: {data['data']['orderId']} -> {data['data']['status']}")
            elif data.get('type') == 'balance':
                print(f"💰 Balance: {data['data']['units']} {data['data']['amount']}")
            elif data.get('type') == 'position':
                print(f"📊 Position: {data['data']['symbol']} PnL: {data['data']['unrealizedPnl']}")

# Run the client
asyncio.run(authenticated_websocket_client('your-api-key', 'your-api-secret'))
```
</CodeGroup>

### cURL Example

For testing authentication, you can use `wscat` or similar tools:

```bash
wscat -c wss://ws.roxom.com/ws \
  --header "X-API-KEY: your-api-key" \
  --header "X-API-TIMESTAMP: $(date +%s000)" \
  --header "X-API-SIGN: $(echo -n $(date +%s000) | openssl dgst -sha256 -hmac 'your-api-secret' -binary | base64)"
```

## Environment Configuration

### Environment Variables

Store your credentials securely using environment variables:

<CodeGroup>
```bash .env
# Production
ROXOM_ENV=production
ROXOM_WS_URL=wss://ws.roxom.com/ws
ROXOM_API_KEY=your_production_api_key
ROXOM_API_SECRET=your_production_api_secret

# Sandbox
ROXOM_ENV=sandbox
ROXOM_WS_URL=wss://ws.roxom.io/ws
ROXOM_API_KEY=your_sandbox_api_key
ROXOM_API_SECRET=your_sandbox_api_secret
```

```javascript JavaScript
const config = {
  production: {
    wsUrl: 'wss://ws.roxom.com/ws',
    apiKey: process.env.ROXOM_PROD_API_KEY,
    apiSecret: process.env.ROXOM_PROD_API_SECRET
  },
  sandbox: {
    wsUrl: 'wss://ws.roxom.io/ws',
    apiKey: process.env.ROXOM_SANDBOX_API_KEY,
    apiSecret: process.env.ROXOM_SANDBOX_API_SECRET
  }
};

const env = process.env.ROXOM_ENV || 'sandbox';
const credentials = config[env];
```

```python Python
import os

config = {
    'production': {
        'ws_url': 'wss://ws.roxom.com/ws',
        'api_key': os.getenv('ROXOM_PROD_API_KEY'),
        'api_secret': os.getenv('ROXOM_PROD_API_SECRET')
    },
    'sandbox': {
        'ws_url': 'wss://ws.roxom.io/ws',
        'api_key': os.getenv('ROXOM_SANDBOX_API_KEY'),
        'api_secret': os.getenv('ROXOM_SANDBOX_API_SECRET')
    }
}

env = os.getenv('ROXOM_ENV', 'sandbox')
credentials = config[env]
```
</CodeGroup>

## Error Handling

### Authentication Errors

<AccordionGroup>
  <Accordion title="Authentication Failed (600010)">
    **Cause**: Invalid API key, timestamp, or signature
    
    **Response**:
    ```json
    {
      "event": "error",
      "code": "600010",
      "msg": "Authentication failed",
      "connId": "01234567-89ab-7def-8123-456789abcdef"
    }
    ```
    
    **Solutions**:
    - Verify API key is correct and active
    - Ensure timestamp is current (within 30 seconds)
    - Check HMAC signature generation
    - Confirm API key has required permissions
  </Accordion>

  <Accordion title="Invalid Timestamp (600011)">
    **Cause**: Timestamp too old or in the future
    
    **Solutions**:
    - Use current system time
    - Sync system clock if necessary
    - Generate timestamp just before connection
  </Accordion>

  <Accordion title="Invalid Signature (600012)">
    **Cause**: Incorrect HMAC signature calculation
    
    **Solutions**:
    - Verify secret key is correct
    - Check signature algorithm (HMAC-SHA256)
    - Ensure base64 encoding is correct
    - Debug signature generation step by step
  </Accordion>
</AccordionGroup>

## Security Best Practices

<AccordionGroup>
  <Accordion title="Credential Management">
    - **Never commit API secrets to version control**
    - Store credentials in environment variables or secure vaults
    - Use different API keys for production and sandbox
    - Rotate API keys periodically
  </Accordion>

  <Accordion title="Connection Security">
    - Always use WSS (secure WebSocket) connections
    - Validate server certificates in production
    - Monitor for unusual connection patterns
    - Implement proper session management
  </Accordion>

  <Accordion title="Error Handling">
    - Don't log sensitive authentication details
    - Implement exponential backoff for failed auth attempts
    - Monitor authentication errors for security incidents
    - Have fallback mechanisms for auth failures
  </Accordion>
</AccordionGroup>

## Complete Authenticated Client

Here's a production-ready authenticated WebSocket client:

```javascript
class SecureRoxomWebSocket {
  constructor(apiKey, apiSecret, environment = 'sandbox') {
    this.apiKey = apiKey;
    this.apiSecret = apiSecret;
    this.environment = environment;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.baseDelay = 1000;
  }

  get wsUrl() {
    return this.environment === 'production' 
      ? 'wss://ws.roxom.com/ws'
      : 'wss://ws.roxom.io/ws';
  }

  generateAuthHeaders() {
    const timestamp = Date.now().toString();
    const signature = this.generateSignature(timestamp);

    return {
      'X-API-KEY': this.apiKey,
      'X-API-TIMESTAMP': timestamp,
      'X-API-SIGN': signature
    };
  }

  generateSignature(timestamp) {
    const crypto = require('crypto');
    return crypto
      .createHmac('sha256', this.apiSecret)
      .update(timestamp)
      .digest('base64');
  }

  async connect() {
    try {
      const headers = this.generateAuthHeaders();
      this.ws = new WebSocket(this.wsUrl, [], { headers });

      this.ws.onopen = () => {
        console.log(`🔐 Authenticated connection to ${this.environment}`);
        this.reconnectAttempts = 0;
        this.onConnected();
      };

      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleMessage(data);
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };

      this.ws.onclose = (event) => {
        console.log(`Connection closed: ${event.code} ${event.reason}`);
        if (event.code !== 1000) { // Not a normal closure
          this.handleReconnect();
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };

    } catch (error) {
      console.error('Connection error:', error);
      this.handleReconnect();
    }
  }

  onConnected() {
    // Override in subclasses or set callback
    console.log('Ready to receive private account data');
  }

  handleMessage(data) {
    if (data.event === 'error') {
      this.handleError(data);
      return;
    }

    switch (data.type) {
      case 'order':
        this.onOrderUpdate?.(data.data);
        break;
      case 'balance':
        this.onBalanceUpdate?.(data.data);
        break;
      case 'position':
        this.onPositionUpdate?.(data.data);
        break;
      default:
        console.log('Unknown message type:', data.type);
    }
  }

  handleError(error) {
    console.error(`WebSocket error ${error.code}: ${error.msg}`);
    
    if (error.code === '600010') { // Authentication failed
      console.error('Authentication failed - check credentials');
      // Don't reconnect on auth failures
      return;
    }
    
    this.handleReconnect();
  }

  handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.baseDelay * Math.pow(2, this.reconnectAttempts - 1);
      
      console.log(`🔄 Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
      
      setTimeout(() => {
        this.connect();
      }, delay);
    } else {
      console.error('❌ Max reconnection attempts reached');
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect');
      this.ws = null;
    }
  }

  // Event handlers (override or set as callbacks)
  onOrderUpdate(orderData) {
    console.log('Order update:', orderData);
  }

  onBalanceUpdate(balanceData) {
    console.log('Balance update:', balanceData);
  }

  onPositionUpdate(positionData) {
    console.log('Position update:', positionData);
  }
}

// Usage
const client = new SecureRoxomWebSocket(
  process.env.ROXOM_API_KEY,
  process.env.ROXOM_API_SECRET,
  'sandbox'
);

client.connect();
```

## Next Steps

- Learn about [Connection Management](/reference/websockets/connection/management) for reliable connections
- Explore [Account Updates](/reference/websockets/account-updates) for private data streams
- Review [API Authentication](/reference/authentication) for REST API credentials setup

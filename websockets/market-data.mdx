---
title: "Market Data Streams"
description: "Real-time market data via WebSocket streams"
---

## Available Market Data Streams

Access real-time market data through WebSocket streams without authentication required.

### Stream Types

| Channel | Description | Update Frequency |
|---------|-------------|------------------|
| `level1` | Best bid/ask quotes | Real-time |
| `trade` | Trade executions with volume stats | Per trade |
| `depth` | Full order book depth | Real-time |
| `ticker` | 24hr rolling statistics | Every second |

## Level 1 Order Book (`level1`)

Real-time best bid and ask prices with quantities.

### Subscribe to Level 1 Data

<RequestExample>
```json Subscribe
{
  "op": "subscribe",
  "args": [
    { "channel": "level1", "symbol": "SP500-BTC" },
    { "channel": "level1", "symbol": "GLD-BTC" }
  ]
}
```
</RequestExample>

### Level 1 Response Format

<ResponseExample>
```json Snapshot
{
  "topic": "level1.SP500-BTC",
  "type": "snapshot",
  "createdTime": 1640995200000000000,
  "data": {
    "symbol": "SP500-BTC",
    "bid": ["0.00432450", "0.5"],
    "ask": ["0.00432500", "0.3"],
    "timestamp": 1640995200000000000
  }
}
```
</ResponseExample>

<ResponseField name="data" type="object">
  Level 1 order book data

  <Expandable title="Level 1 properties">
    <ResponseField name="symbol" type="string">
      Trading pair symbol
    </ResponseField>
    
    <ResponseField name="bid" type="array">
      [price, quantity] - Best bid price and size
    </ResponseField>
    
    <ResponseField name="ask" type="array">
      [price, quantity] - Best ask price and size  
    </ResponseField>
    
    <ResponseField name="timestamp" type="integer">
      Update timestamp in nanoseconds
    </ResponseField>
  </Expandable>
</ResponseField>

### Level 1 Implementation

```javascript
const ws = new WebSocket('wss://ws.roxom.com/ws');

ws.onopen = function() {
  // Subscribe to BTC and ETH level 1 data
  ws.send(JSON.stringify({
    op: 'subscribe',
    args: [
      { channel: 'level1', symbol: 'SP500-BTC' },
      { channel: 'level1', symbol: 'GLD-BTC' }
    ]
  }));
};

ws.onmessage = function(event) {
  const data = JSON.parse(event.data);
  
  if (data.topic && data.topic.startsWith('level1.')) {
    const symbol = data.data.symbol;
    const bid = data.data.bid;
    const ask = data.data.ask;
    const spread = parseFloat(ask[0]) - parseFloat(bid[0]);
    
    console.log(`${symbol} - Bid: ${bid[0]} (${bid[1]}) Ask: ${ask[0]} (${ask[1]}) Spread: ${spread.toFixed(2)}`);
    
    // Update your UI or trading logic
    updateOrderBook(symbol, bid, ask);
  }
};

function updateOrderBook(symbol, bid, ask) {
  // Update your application's order book display
  document.getElementById(`${symbol}-bid`).textContent = `${bid[0]} (${bid[1]})`;
  document.getElementById(`${symbol}-ask`).textContent = `${ask[0]} (${ask[1]})`;
}
```

## Trade Executions (`trade`)

Real-time trade execution data with volume and price statistics.

### Subscribe to Trade Data

<RequestExample>
```json Subscribe
{
  "op": "subscribe",
  "args": [
    { "channel": "trade", "symbol": "SP500-BTC" }
  ]
}
```
</RequestExample>

### Trade Response Format

<ResponseExample>
```json Trade Event
{
  "topic": "trade.SP500-BTC", 
  "type": "snapshot",
  "createdTime": 1640995200000000000,
  "data": {
    "symbol": "SP500-BTC",
    "takerSide": "buy",
    "vwap": "0.00432450",
    "volume": "1247.85", 
    "minPx": "0.00432400",
    "maxPx": "0.00432500",
    "timestamp": 1640995200000000000
  }
}
```
</ResponseExample>

<ResponseField name="data" type="object">
  Trade execution data

  <Expandable title="Trade properties">
    <ResponseField name="symbol" type="string">
      Trading pair symbol
    </ResponseField>
    
    <ResponseField name="takerSide" type="string">
      Side of the aggressor: "buy" or "sell"
    </ResponseField>
    
    <ResponseField name="vwap" type="string">
      Volume weighted average price
    </ResponseField>
    
    <ResponseField name="volume" type="string">
      Total trade volume in quote currency
    </ResponseField>
    
    <ResponseField name="minPx" type="string">
      Minimum trade price in the period
    </ResponseField>
    
    <ResponseField name="maxPx" type="string">
      Maximum trade price in the period
    </ResponseField>
    
    <ResponseField name="timestamp" type="integer">
      Trade timestamp in nanoseconds
    </ResponseField>
  </Expandable>
</ResponseField>

### Trade Stream Implementation

```python
import websocket
import json

class TradeMonitor:
    def __init__(self):
        self.ws = None
        self.trade_history = {}
        
    def connect(self):
        self.ws = websocket.WebSocketApp(
            "wss://ws.roxom.com/ws",
            on_open=self.on_open,
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close
        )
        self.ws.run_forever()
    
    def on_open(self, ws):
        print("Connected to trade stream")
        # Subscribe to multiple symbols
        subscribe_msg = {
            "op": "subscribe",
            "args": [
                {"channel": "trade", "symbol": "SP500-BTC"},
                {"channel": "trade", "symbol": "GLD-BTC"}
            ]
        }
        ws.send(json.dumps(subscribe_msg))
    
    def on_message(self, ws, message):
        data = json.loads(message)
        
        if data.get('topic', '').startswith('trade.'):
            self.handle_trade(data['data'])
    
    def handle_trade(self, trade_data):
        symbol = trade_data['symbol']
        side = trade_data['takerSide']
        vwap = float(trade_data['vwap'])
        volume = float(trade_data['volume'])
        
        # Store trade data
        if symbol not in self.trade_history:
            self.trade_history[symbol] = []
        
        self.trade_history[symbol].append({
            'price': vwap,
            'volume': volume,
            'side': side,
            'timestamp': trade_data['timestamp']
        })
        
        # Keep only last 100 trades per symbol
        if len(self.trade_history[symbol]) > 100:
            self.trade_history[symbol] = self.trade_history[symbol][-100:]
        
        print(f"{symbol}: {side.upper()} at {vwap} (Vol: {volume})")
        
        # Analyze trade patterns
        self.analyze_trade_pattern(symbol)
    
    def analyze_trade_pattern(self, symbol):
        if symbol not in self.trade_history or len(self.trade_history[symbol]) < 10:
            return
            
        recent_trades = self.trade_history[symbol][-10:]
        buy_volume = sum(t['volume'] for t in recent_trades if t['side'] == 'buy')
        sell_volume = sum(t['volume'] for t in recent_trades if t['side'] == 'sell')
        
        if buy_volume > sell_volume * 1.5:
            print(f"ðŸŸ¢ {symbol}: Strong buying pressure detected")
        elif sell_volume > buy_volume * 1.5:
            print(f"ðŸ”´ {symbol}: Strong selling pressure detected")

# Usage
monitor = TradeMonitor()
monitor.connect()
```

## Order Book Depth (`depth`)

Complete order book with multiple price levels on both sides.

### Subscribe to Depth Data

<RequestExample>
```json Subscribe
{
  "op": "subscribe",
  "args": [
    { "channel": "depth", "symbol": "SP500-BTC" }
  ]
}
```
</RequestExample>

### Depth Response Format

<ResponseExample>
```json Snapshot
{
  "topic": "depth.SP500-BTC",
  "type": "snapshot",
  "createdTime": 1640995200000000000,
  "data": {
    "symbol": "SP500-BTC",
    "bid": [
      ["49950.00", "1.25"],
      ["49945.00", "2.50"],
      ["49940.00", "0.75"]
    ],
    "ask": [
      ["50050.00", "1.50"], 
      ["50055.00", "3.25"],
      ["50060.00", "1.00"]
    ],
    "timestamp": 1640995200000000000
  }
}
```

```json Delta Update
{
  "topic": "depth.SP500-BTC",
  "type": "delta",
  "createdTime": 1640995200000000000,
  "data": {
    "symbol": "SP500-BTC",
    "bid": [
      ["49950.00", "0.00"],  // Removed (quantity = 0)
      ["49948.00", "2.00"]   // Added/Updated
    ],
    "ask": [],
    "timestamp": 1640995200000000000
  }
}
```
</ResponseExample>

<ResponseField name="data" type="object">
  Order book depth data

  <Expandable title="Depth properties">
    <ResponseField name="symbol" type="string">
      Trading pair symbol
    </ResponseField>
    
    <ResponseField name="bid" type="array">
      Array of [price, quantity] pairs sorted by price descending
    </ResponseField>
    
    <ResponseField name="ask" type="array">
      Array of [price, quantity] pairs sorted by price ascending
    </ResponseField>
    
    <ResponseField name="type" type="string">
      "snapshot" for full data, "delta" for incremental updates
    </ResponseField>
    
    <ResponseField name="timestamp" type="integer">
      Update timestamp in nanoseconds
    </ResponseField>
  </Expandable>
</ResponseField>

### Order Book Management

```javascript
class OrderBookManager {
  constructor() {
    this.orderBooks = {};
  }

  connect() {
    this.ws = new WebSocket('wss://api.roxom.com/ws');
    
    this.ws.onopen = () => {
      console.log('Connected to depth stream');
      this.subscribe(['SP500-BTC', 'GLD-BTC']);
    };

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.topic && data.topic.startsWith('depth.')) {
        this.handleDepthUpdate(data);
      }
    };
  }

  subscribe(symbols) {
    const args = symbols.map(symbol => ({
      channel: 'depth',
      symbol: symbol
    }));

    this.ws.send(JSON.stringify({
      op: 'subscribe',
      args: args
    }));
  }

  handleDepthUpdate(data) {
    const symbol = data.data.symbol;
    const type = data.type;

    if (!this.orderBooks[symbol]) {
      this.orderBooks[symbol] = { bids: {}, asks: {} };
    }

    if (type === 'snapshot') {
      // Replace entire order book
      this.orderBooks[symbol] = this.buildOrderBook(data.data);
    } else if (type === 'delta') {
      // Apply incremental updates
      this.applyDelta(symbol, data.data);
    }

    // Calculate market metrics
    this.calculateMetrics(symbol);
  }

  buildOrderBook(data) {
    const orderBook = { bids: {}, asks: {} };

    // Process bids
    data.bid.forEach(([price, quantity]) => {
      if (parseFloat(quantity) > 0) {
        orderBook.bids[price] = parseFloat(quantity);
      }
    });

    // Process asks
    data.ask.forEach(([price, quantity]) => {
      if (parseFloat(quantity) > 0) {
        orderBook.asks[price] = parseFloat(quantity);
      }
    });

    return orderBook;
  }

  applyDelta(symbol, data) {
    const orderBook = this.orderBooks[symbol];

    // Apply bid updates
    data.bid.forEach(([price, quantity]) => {
      const qty = parseFloat(quantity);
      if (qty === 0) {
        delete orderBook.bids[price];
      } else {
        orderBook.bids[price] = qty;
      }
    });

    // Apply ask updates  
    data.ask.forEach(([price, quantity]) => {
      const qty = parseFloat(quantity);
      if (qty === 0) {
        delete orderBook.asks[price];
      } else {
        orderBook.asks[price] = qty;
      }
    });
  }

  calculateMetrics(symbol) {
    const orderBook = this.orderBooks[symbol];
    
    // Get best bid and ask
    const bestBid = Math.max(...Object.keys(orderBook.bids).map(Number));
    const bestAsk = Math.min(...Object.keys(orderBook.asks).map(Number));
    
    // Calculate spread
    const spread = bestAsk - bestBid;
    const spreadPercent = (spread / bestBid) * 100;
    
    // Calculate total volume (top 10 levels)
    const bidVolume = this.calculateVolume(orderBook.bids, 10);
    const askVolume = this.calculateVolume(orderBook.asks, 10);
    
    console.log(`${symbol} Metrics:`);
    console.log(`  Spread: $${spread.toFixed(2)} (${spreadPercent.toFixed(3)}%)`);
    console.log(`  Bid Volume: ${bidVolume.toFixed(4)}`);
    console.log(`  Ask Volume: ${askVolume.toFixed(4)}`);
  }

  calculateVolume(levels, maxLevels) {
    const sortedPrices = Object.keys(levels)
      .map(Number)
      .sort((a, b) => b - a) // Descending for bids
      .slice(0, maxLevels);
    
    return sortedPrices.reduce((total, price) => {
      return total + levels[price];
    }, 0);
  }

  getBestPrices(symbol) {
    const orderBook = this.orderBooks[symbol];
    if (!orderBook) return null;

    const bestBid = Math.max(...Object.keys(orderBook.bids).map(Number));
    const bestAsk = Math.min(...Object.keys(orderBook.asks).map(Number));

    return {
      bid: bestBid,
      ask: bestAsk,
      spread: bestAsk - bestBid
    };
  }
}

// Usage
const orderBookManager = new OrderBookManager();
orderBookManager.connect();
```

## Multiple Symbol Subscriptions

Subscribe to multiple symbols efficiently:

```javascript
function subscribeToMultipleStreams() {
  const ws = new WebSocket('wss://ws.roxom.com/ws');
  
  ws.onopen = function() {
    // Subscribe to multiple symbols and channels in one message
    ws.send(JSON.stringify({
      op: 'subscribe',
      args: [
        // Level 1 for major pairs
        { channel: 'level1', symbol: 'SP500-BTC' },
        { channel: 'level1', symbol: 'GLD-BTC' },
        
        // Trade data for active monitoring
        { channel: 'trade', symbol: 'SP500-BTC' },
        { channel: 'trade', symbol: 'GLD-BTC' },
        
        // Depth for algorithmic trading
        { channel: 'depth', symbol: 'SP500-BTC' }
      ]
    }));
  };

  ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    
    // Route messages based on channel
    if (data.topic) {
      const [channel, symbol] = data.topic.split('.');
      
      switch (channel) {
        case 'level1':
          handleLevel1Update(symbol, data.data);
          break;
        case 'trade':
          handleTradeUpdate(symbol, data.data);
          break;
        case 'depth':
          handleDepthUpdate(symbol, data.data);
          break;
      }
    }
  };
}

function handleLevel1Update(symbol, data) {
  console.log(`${symbol} Level 1: Bid ${data.bid[0]} Ask ${data.ask[0]}`);
}

function handleTradeUpdate(symbol, data) {
  console.log(`${symbol} Trade: ${data.takerSide} ${data.vwap} Vol: ${data.volume}`);
}

function handleDepthUpdate(symbol, data) {
  console.log(`${symbol} Depth: ${data.type} update`);
}
```

## Unsubscribing from Streams

Remove subscriptions when no longer needed:

<RequestExample>
```json Unsubscribe
{
  "op": "unsubscribe",
  "args": [
    { "channel": "trade", "symbol": "GLD-BTC" },
    { "channel": "depth", "symbol": "SP500-BTC" }
  ]
}
```
</RequestExample>

<CardGroup cols={2}>
  <Card
    title="Account Updates"
    icon="user"
    href="/websockets/account-updates"
  >
    Real-time account and order updates
  </Card>
  <Card
    title="Connection Setup"
    icon="plug"
    href="/websockets/connection"
  >
    Establish WebSocket connections
  </Card>
</CardGroup>